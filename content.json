{"pages":[{"title":"Untitled","text":"","link":"/Untitled/index-1.html"},{"title":"Untitled","text":"","link":"/Untitled/index.html"}],"posts":[{"title":"使用volley获取HTTP网络请求接口的响应头","text":"一丶解决这个问题的时候先得知道什么响应头，与之对应的还有请求头 二.找到volley内部访问请求返回的response，并获取响应头信息 12345678910protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, &quot;UTF-8&quot;); LogUtil.e(&quot;Header&quot;, response.headers.toString()); } catch (UnsupportedEncodingException var4) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));} volley内部返回的response可以获取到Header信息，由于header信息是map类型的，所以要获取某个key的值，则通过 response.headers.get(“key”)来获取。","link":"/2020/01/17/%E4%BD%BF%E7%94%A8volley%E8%8E%B7%E5%8F%96HTTP%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4/"},{"title":"将vue项目部署到服务器并通过外网访问的两种方式（springboot中static/nginx）","text":"最近一段时间在用vue写一个前端项目，想着做出来的界面可以让小伙伴们一起看看，分享一下。所以就趁着双11在阿里云买了台服务器。实践中我发现vue项目部署到服务器一共有两种方式，当然也有可能有别的方法。 一.将vue项目打包后生成的dist目录下的文件复制到springboot项目里面 前端vue项目先通过npm run build生成dist目录 2.将dist中目录文件放入springboot项目的resources目录下的static文件夹 3.运行springboot项目，在浏览器地址栏输入localhost:port/index.html(port为后端项目设置的端口号，我设的为8088），所以我输入localhost:8088/index.html即可访问到前端项目 问题来了，这时候会有小伙伴问你这只是本地通过localhost来访问的，别人也访问不了看不到，不是说用外网查看的吗，下面是用外网查看该网页。 4.通过mvn package将springboot项目打包，生成jar包，然后登陆你的阿里云服务器，将jar放到服务器并运行jar包，即可通过外网访问。 ①到项目根目录打开cmd，输入mvn package进行打包，生成jar文件。 ②将jar包放到你的服务器上（我买的是阿里云） 并执行java -jar memoryTravel-0.0.1-SNAPSHOT.jar，即可运行jar包，项目也就运行起来了。这时候你就可以通过服务器的外网ip来访问前端的界面。 而我已经做过域名解析了，所以输入www.fengchi.site:8088/index.html也是可以访问的。 二.将vue项目部署到nginx服务器上，通过设置conf配置文件来进行外网访问。 下载安装nginx，从官网（nginx官网）下载回来解压就好了。接下来打开命令窗口运行nginx服务器 2.修改nginx.conf配置文件 修改过配置文件运行 ./nginx -s reload这时候你就可以通过你的外网ip+你设置的端口去访问你的前端项目了（我这里已经把47.105.177.109解决成www.fengchi.site这个域名了）","link":"/2020/01/17/%E5%B0%86vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E9%80%9A%E8%BF%87%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88springboot%E4%B8%ADstatic-nginx%EF%BC%89/"},{"title":"React antd的FormItem结合switch设置initialValue无效","text":"当antd formItem结合switch设置initialValue无效时，需要在getFieldDecorator 包装的控件中添加代码valuePropName: ‘checked’，最后的代码呈现是这样的： 123456789&lt;FormItem labelCol={{ span: 5 }} wrapperCol={{ span: 5,offset: 12 }} label=&quot;退回权限&quot;&gt; {form.getFieldDecorator('allowReject', { required: true, initialValue:values.allowReject, valuePropName: 'checked' })( &lt;Switch onChange={approveChange}&gt;&lt;/Switch&gt; )}&lt;/FormItem&gt;","link":"/2020/02/12/React-antd%E7%9A%84FormItem%E7%BB%93%E5%90%88switch%E8%AE%BE%E7%BD%AEinitialValue%E6%97%A0%E6%95%88/"},{"title":"微信小程序Img标签中斜杠(/)与反斜杠(\\)的区别","text":"最近在写微信小程序，其实里面的坑还是又不少的。今天就遇到一个正反斜杠的问题。正好今天写的是图片上传的模块，本地先上传文件，返回给你一段服务器上的图片的地址，然后在小程序端显示。结果在返回的地址是 后来我在img标签下的src属性放入了这个地址，结果就是图片怎么也出不来。后来分析下来原来是src里面放入的是网络地址，必须使用正斜杠（/），而返回给我的地址中存在反斜杠（\\），所以图片加载不出来。后来使用了字符串的replace方法替换即 replace(/\\\\/g,'/');//替换&quot;\\&quot;为&quot;/&quot; 最后替换后的地址是 重新编译成功！","link":"/2020/02/13/1/"},{"title":"react中使用canvas进行图片合成","text":"最近react项目里需要动态变换图片里的某一个部件，然后整张图片重新加载。想了一下之前在java里是使用的ImageIO和BufferedImage进行合成的，看了一下由于项目需求是动态变换图片的，所以想的方法是利用canvas定义一个画布，然后drawImage，最后使用canvas.toDataURL转换成base64的图片，可供下载。项目代码如下，一个js文件即可实现功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import React, { Component } from 'react';class photoSynthesis extends React.Component { constructor(props) { super(props) this.initCanvas = this.initCanvas.bind(this) } initCanvas() { let canvas1 = document.getElementById(&quot;customCanvas&quot;); canvas1.width = 800; canvas1.height = 1300; let context1 = canvas1.getContext(&quot;2d&quot;); context1.rect(0 , 0 , canvas1.width , canvas1.height); context1.fillStyle = &quot;#fff&quot;; context1.fill(); var myImage = new Image(); myImage.src = require(&quot;./diaoding.png&quot;); //背景图片 你自己本地的图片或者在线图片 myImage.crossOrigin = 'Anonymous'; myImage.onload = function(){ context1.drawImage(myImage , 0 , 0 , 627 , 262); // context1.font = &quot;60px Courier New&quot;; // context1.fillText(&quot;合成的图片&quot;,350,450); var myImage2 = new Image(); myImage2.src = require(&quot;./zuoce.png&quot;); //你自己本地的图片或者在线图片 myImage2.crossOrigin = 'Anonymous'; myImage2.onload = function(){ context1.drawImage(myImage2 , 0 , 0 , 138 , 1226); //var base64 = canvas1.toDataURL(&quot;image/png&quot;); //&quot;image/png&quot; 这里注意一下 //var img = document.getElementById('avatar'); // document.getElementById('avatar').src = base64; //img.setAttribute('src' , base64); var myImage3 = new Image(); myImage3.src = require(&quot;./houbi1.png&quot;); //你自己本地的图片或者在线图片 myImage3.crossOrigin = 'Anonymous'; myImage3.onload = function(){ context1.drawImage(myImage3 , 136 , 260 , 360 , 700); //var base64 = canvas1.toDataURL(&quot;image/png&quot;); //&quot;image/png&quot; 这里注意一下 var myImage4 = new Image(); myImage4.src = require(&quot;./youce.png&quot;); //你自己本地的图片或者在线图片 myImage4.crossOrigin = 'Anonymous'; myImage4.onload = function(){ context1.drawImage(myImage4 , 490 , 0 , 135 , 1205); var myImage5 = new Image(); myImage5.src = require(&quot;./diban.png&quot;); //你自己本地的图片或者在线图片 myImage5.crossOrigin = 'Anonymous'; myImage5.onload = function(){ context1.drawImage(myImage5 , 0 , 954 , 630 , 255); var base64 = canvas1.toDataURL(&quot;image/png&quot;); //&quot;image/png&quot; 这里注意一下 //var img = document.getElementById('avatar'); // document.getElementById('avatar').src = base64; //img.setAttribute('src' , base64); } } } } } } componentDidMount() { this.initCanvas() } componentDidUpdate() { this.initCanvas() } render() { const { width, height, canvaswidth, canvasheight } = this.props return ( &lt;div style={{ display:&quot;flex&quot;,flexDirection:&quot;column&quot; }}&gt; &lt;div style={{ display:&quot;flex&quot;,flexDirection:&quot;row&quot; }}&gt; &lt;img style={{ width: 200, height: 83, padding: 10 }} src={require('./diaoding.png')}&gt;&lt;/img&gt; &lt;img style={{ width: 100, height: 200, padding: 10 }} src={require('./zuoce.png')}&gt;&lt;/img&gt; &lt;img style={{ width: 103, height: 200, padding: 10 }} src={require('./houbi1.png')}&gt;&lt;/img&gt; &lt;img style={{ width: 100, height: 200, padding: 10 }} src={require('./youce.png')}&gt;&lt;/img&gt; &lt;img style={{ width: 200, height: 84, padding: 10 }} src={require('./diban.png')}&gt;&lt;/img&gt; &lt;/div&gt; &lt;canvas id=&quot;customCanvas&quot; width={canvaswidth} height={canvasheight}&gt;&lt;/canvas&gt; {/* &lt;img id=&quot;avatar&quot; &gt;&lt;/img&gt; */} &lt;/div&gt; ) }}export default photoSynthesis; csdn链接：https://blog.csdn.net/qq_28670711/article/details/104358345","link":"/2020/02/17/react%E4%B8%AD%E4%BD%BF%E7%94%A8canvas%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"},{"title":"hexo绑定个人域名以及如何发布博客","text":"绑定个人域名用 hexo 搭建的个人博客，服务器用的是 github 的，然后域名默认也是 github 下的二级域名：username.github.io,我使用的是monologue95.github.io。绑定域名一共三个步骤 ①先在阿里云域名管理的地方进行域名解析 ②设置CNAME 在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。 ③在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。 域名配置完成，可以通过blog.fengchi.site访问了 如何发布博客通过hexo admin来管理博客 通过localhost://4000/admin来管理 然后通过hexo g或者hexo generate去生成静态文件 然后在通过hexo d或者hexo deploy去部署网站上传到github 再次访问博客，即可发布成功","link":"/2020/03/06/hexo%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"},{"title":"Js数组整理（React中用数组定位到col，row)）","text":"项目中遇到了一个需求，要求按照返回的数据的category进行分类，然后再根据row，col字段去调整每个item在哪一行那一列，所有先看后台返回给我这样的一个数组。 观察下来就是一个简单的数组，里面有大概多少条数据，不存在任何的层级关系。 一.根据项目需要，我们先得把数组按照category字段分类。遇到写了一个方法去整理这个数组。方法如下：1234567891011121314151617181920212223242526272829303132function analysisArray(data){ var moth = [], flag = 0, list = data; var wdy = { title: '', sub_item: '' } for (var i = 0; i &lt; list.length; i++) { var az = ''; for (var j = 0; j &lt; moth.length; j++) { if (moth[j].title == list[i]['category']) { flag = 1; az = j; break; } } if (flag == 1) { var ab = moth[az]; ab.sub_item.push(list[i]); flag = 0; } else if (flag == 0) { wdy = {}; wdy.title = list[i]['category']; wdy.sub_item = new Array(); wdy.sub_item.push(list[i]); moth.push(wdy); } } return moth;} 通过这个方法我们可以实现category分类。如下图 二.要将每个分类里面的处于同一行的再整理，按照row去整理，这样遍历数组时才能实现定位，一行有几条数据，一共有多少行。方法如下：12345678910111213141516171819202122232425function analysisCol(subItem){ var list = subItem, flag = 0, data = []; for(var i = 0; i&lt; list.length; i++) { var az = ''; for (var j = 0; j &lt; data.length; j++) { if(data[j][0].row == list[i].row) { flag = 1; az = j; break; } } if(flag == 1){ data[az].push(list[i]); flag = 0; } else if (flag == 0) { var wdy = new Array(); wdy.push(list[i]); data.push(wdy); } } return data;} 通过遍历按照category分类的数组，然后取出里面的sub_item子项数组，调用该方法，最后得出的数组如下：先按照category分类，再按照row去分类，得出我们要的数组，最后通过3重循环，就可以得到我们想到的效果了。代码如下： { Array.isArray(codData)?codData.map((item,index) =&gt; ( &lt;Card title={item.title} type=&quot;inner&quot; id={index} key={index}&gt; &lt;div&gt; &lt;Row&gt; { item.sub_item.map((values, index) =&gt; { return ( &lt;Row&gt; { values.map((itemValues, itemIndex) =&gt; { const optionArr = itemValues.scope ? itemValues.scope.split(&quot;;&quot;) : [&quot;&quot;]; return ( &lt;span key={itemIndex}&gt; &lt;Col span={4} style={{ marginBottom: 8 }}&gt; &lt;div style={{ lineHeight: 2 }}&gt; {itemValues.name} : &amp;nbsp; &lt;/div&gt; &lt;/Col&gt; &lt;Col span={4} style={{ marginBottom: 8 }}&gt; { itemValues.type &amp;&amp; itemValues.type === &quot;下拉框&quot; ? ( &lt;Select value={itemValues.value} style={{ width: 150 }} onChange={(record) =&gt; this.changeOptionValue(record,itemValues)}&gt; {optionArr.map(optionKey =&gt; ( &lt;Option value={optionKey}&gt;{optionKey}&lt;/Option&gt; ))} &lt;/Select&gt; ) : ( &lt;Input style={{ width: 150 }} onChange={(e) =&gt; this.changeInputValue(e.target.value,itemValues)} defaultValue={itemValues.value} /&gt; ) } &lt;/Col&gt; &lt;/span&gt; ) //截止点 }) } &lt;/Row&gt;//第二截止点 ) }) } &lt;/Row&gt; &lt;/div&gt; &lt;/Card&gt; )):null }","link":"/2020/03/26/Js%E6%95%B0%E7%BB%84%E6%95%B4%E7%90%86%EF%BC%88React%E4%B8%AD%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9A%E4%BD%8D%E5%88%B0col%EF%BC%8Crow-%EF%BC%89/"},{"title":"如何在React中引入外部js","text":"推荐使用插件react-load-script来引入外部js，如果没有安装可以使用yarn add react-load-script 或者 npm install react-load-script。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';import Script from 'react-load-script';class ScriptExample extends React.Component { constructor(props) { super(props); this.state = { scriptStatus: 'no' } } handleScriptCreate() { this.setState({ scriptLoaded: false }) } handleScriptError() { this.setState({ scriptError: true }) } handleScriptLoad() { this.setState({ scriptLoaded: true, scriptStatus: 'yes' }) } render() { return ( &lt;&gt; &lt;Script url=&quot;https://cdn.staticfile.org/jquery/3.3.1/jquery.min.js&quot; onCreate={this.handleScriptCreate.bind(this)} onError={this.handleScriptError.bind(this)} onLoad={this.handleScriptLoad.bind(this)} /&gt; &lt;div&gt;动态脚本引入状态：{this.state.scriptStatus}&lt;/div&gt; &lt;/&gt; ); }}export default ScriptExample;","link":"/2020/03/31/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8js/"},{"title":"react中使用Cascader完成（国省市区街）级联选择","text":"因为项目里有多个地方需要去选择省市区，所以就想着用cascader做一下省市区级联，因为详细到选国家和街道的组件比较少，所以就自己封装了一个组件，供大家使用。 这是组件的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import { Component } from 'react';import { Cascader } from 'antd'; import * as addressRequest from '../../services/address'; export default class AreaPicker extends Component { constructor(props) { super(props); if(Array.isArray(this.props.selectArea)){ this.state = { options: [], defaultValue: this.props.selectArea }; }else{ this.state = { options: [], defaultValue:&quot;&quot; }; } } componentDidMount() { const {selectArea} =this.props if(Array.isArray(selectArea)&amp;&amp;selectArea.length&gt;0){ this.getAllOpt(); console.log(&quot;编辑地址&quot;) }else{ this.getProvinceOpt(); console.log(&quot;新建地址&quot;) } } onChange = (value) =&gt; { /**给父组件通知值变化*/ this.props.onAreaChange(value); }; loadData = selectedOptions =&gt; { let targetOption = selectedOptions[selectedOptions.length - 1]; targetOption.loading = true; /**获取省列表*/ if (selectedOptions.length == 1) { addressRequest.queryAddressList(targetOption.value).then(res =&gt; { targetOption.loading = false; let list = []; res.data.forEach(el =&gt; list.push({ label: el.name, value: el.id, isLeaf: false }) ); targetOption.children = list; this.setState({ options: [...this.state.options] }); }); } else if (selectedOptions.length == 2) { /**获取市列表 */ addressRequest.queryAddressList(targetOption.value).then(res =&gt; { targetOption.loading = false; let list = []; res.data.forEach(el =&gt; list.push({ label: el.name, value: el.id, isLeaf: false }) ); targetOption.children = list; this.setState({ options: [...this.state.options] }); }); }else if (selectedOptions.length == 3) { /**获取区列表 */ addressRequest.queryAddressList(targetOption.value).then(res =&gt; { targetOption.loading = false; let list = []; res.data.forEach(el =&gt; list.push({ label: el.name, value: el.id, isLeaf: false }) ); targetOption.children = list; this.setState({ options: [...this.state.options] }); }); }else if (selectedOptions.length == 4) { /**获取街道列表 */ addressRequest.queryAddressList(targetOption.value).then(res =&gt; { targetOption.loading = false; let list = []; res.data.forEach(el =&gt; list.push({ label: el.name, value: el.id }) ); targetOption.children = list; this.setState({ options: [...this.state.options] }); }); } console.log(&quot;options2&quot;,this.state.options) }; /**没有默认值时初始化省列表 */ getProvinceOpt() { addressRequest.queryAddressList('0').then(res =&gt; { let list = []; res.data.forEach(el =&gt; { list.push({ label: el.name, value: el.id, isLeaf: false }); }); this.setState({ options: list }); }); console.log(&quot;options1&quot;,this.state.options) } /**有默认选中的值时对数据进行初始化 */ getAllOpt() { console.log(&quot;根据默认值选中&quot;,&quot;根据默认值选中&quot;) const {selectArea} =this.props; let list1 = [] let list2 = [] let list3 = [] let list4 = [] let list5 = [] //获取街道 if(selectArea[3]){ addressRequest.queryAddressList(selectArea[3]).then(res =&gt; { res.data.forEach(el =&gt; list5.push({ label: el.name, value: el.id }) ); //获取区 if(selectArea[2]){ addressRequest.queryAddressList(selectArea[2]).then(res =&gt; { res.data.forEach(el =&gt; list4.push({ label: el.name, value: el.id, isLeaf: false, children: selectArea[3] == el.id ? list5 : null }) ); //获取市 if(selectArea[1]){ addressRequest.queryAddressList(selectArea[1]).then(res =&gt; { res.data.forEach(el =&gt; list3.push({ label: el.name, value: el.id, isLeaf: false, children: selectArea[2] == el.id ? list4 : null }) ); //获取省 if(selectArea[0]){ addressRequest.queryAddressList(selectArea[0]).then(res =&gt; { res.data.forEach(el =&gt; list2.push({ label: el.name, value: el.id, isLeaf: false, children: selectArea[1] == el.id ? list3 : null }) ); //获取国家 if(true){ addressRequest.queryAddressList(&quot;0&quot;).then(res =&gt; { res.data.forEach(el =&gt; list1.push({ label: el.name, value: el.id, isLeaf: false, children: selectArea[0] == el.id ? list2 : null }) ); this.setState({ options: list1 }); })}; })}; })}; })}; })}; } render() { const {style,selectArea} =this.props; return ( &lt;Cascader options={this.state.options} value={selectArea} loadData={this.loadData.bind(this)} onChange={this.onChange.bind(this)} style={style} changeOnSelect placeholder=&quot;请选择&quot; /&gt; ); }} 调用它的地方只需要传入style和selectArea即可使用 这是调用组件的代码 12345&lt;AreaPicker selectArea={selectedValues} onAreaChange={this.onAreaChange} style={{ width: 450, marginLeft: 25 }}/&gt; 1234567891011121314151617181920212223onAreaChange = e =&gt;{ console.log(&quot;selectedValues&quot;,e) let address={}; if(e[0]){ Object.assign(address,{countryId:(e[0])}) } if(e[1]){ Object.assign(address,{provinceId:(e[1])}) } if(e[2]){ Object.assign(address,{cityId:(e[2])}) } if(e[3]){ Object.assign(address,{areaId:(e[3])}) } if(e[4]){ Object.assign(address,{streetId:(e[4])}) } this.setState({ address:address, selectedValues:e }) } 这是service的代码 123456789101112import request from '@/utils/request';import { getConfig } from './config';import { stringify } from 'qs';const HOST = `${getConfig('dev').HOST }/eip-service-crm`;// 查看国家省市县列表export async function queryAddressList(id) { return request(`${HOST}/world/listAddress/${id}`, { method: 'GET', });} 至此，封装 国省市区街的组件就写好了，当然如果你想要省市区的功能，只需要把组件代码里的list数组调整一下就好了","link":"/2020/03/31/react%E4%B8%AD%E4%BD%BF%E7%94%A8Cascader%E5%AE%8C%E6%88%90%EF%BC%88%E5%9B%BD%E7%9C%81%E5%B8%82%E5%8C%BA%E8%A1%97%E9%81%93%EF%BC%89%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9/"},{"title":"如何在同一域名不同端口的两个平台实现自动登录（通过cookie实现））","text":"现在项目有这样一个需求,有两个平台，当一个平台已经登录好之后，另外一个平台可以自动登录上，不要重新登录了，这就要求用户信息以及token未登录的平台是要能获取到了。已知这两个平台是同一域名不同端口，所有localStorage是肯定不能共享的，所以就采用cookie的方法。代码及思路如下： 在第一个平台登录成功的时候不仅要往自己的localStorage存用户信息和token，也往cookie存入用户信息和token。 1setCookie('token',encodeURIComponent(response.data.token)); 这样就把token存到cookie中， 登录另外一个系统时，就要先判断localStorage中是否有token，没有的话去cookie里获取 1localStorage.setItem('token',decodeURIComponent(getCookie(&quot;token&quot;))); 以下是setcookie和getcookie的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 export function setCookie(cName, value, expiredays) { const exdate = new Date(); exdate.setTime(Number(exdate) + expiredays); document.cookie = `${cName }=${ escape(value) }; path=/${ expiredays == null ? '' : `;expires=${ exdate.toGMTString()}`}`;}export function getCookie(cName) { if (document.cookie.length &gt; 0) { let cStart = document.cookie.indexOf(`${cName }=`); // 获取字符串的起点 if (cStart !== -1) { cStart = cStart + cName.length + 1; // 获取值的起点 let cEnd = document.cookie.indexOf(';', cStart); // 获取结尾处 if (cEnd === -1) cEnd = document.cookie.length; // 如果是最后一个，结尾就是cookie字符串的结尾 return decodeURI(document.cookie.substring(cStart, cEnd)); // 截取字符串返回 } } return '';}export function setCookie(cName, value, expiredays) { const exdate = new Date(); exdate.setTime(Number(exdate) + expiredays); document.cookie = `${cName }=${ escape(value) }; path=/${ expiredays == null ? '' : `;expires=${ exdate.toGMTString()}`}`;}export function getCookie(cName) { if (document.cookie.length &gt; 0) { let cStart = document.cookie.indexOf(`${cName }=`); // 获取字符串的起点 if (cStart !== -1) { cStart = cStart + cName.length + 1; // 获取值的起点 let cEnd = document.cookie.indexOf(';', cStart); // 获取结尾处 if (cEnd === -1) cEnd = document.cookie.length; // 如果是最后一个，结尾就是cookie字符串的结尾 return decodeURI(document.cookie.substring(cStart, cEnd)); // 截取字符串返回 } } return '';} 当然会存在token过期的情况，这些就需要你根据实际项目需求去改了。","link":"/2020/04/09/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%EF%BC%88%E9%80%9A%E8%BF%87cookie%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%89/"},{"title":"如何在react中使用websocket","text":"一.如何引用websocketnpm install –save react-websocket 二.在组件中如何使用1.先封装一个websocket组件 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import Websocket from 'react-websocket';class ReactWebsocket extends React.Component { handleData(data) { this.props.onMessage(data) } handleOpen(value){ this.props.onOpen(value); // this.refWebSocket.sendMessage(value); } handleClose() { this.props.onClose() } sendMessage(message){ this.refWebSocket.sendMessage(message); } render() { const {url,reconnect,debug} =this.props; return ( &lt;Websocket url={url} onMessage={this.handleData.bind(this)} onOpen={this.handleOpen.bind(this)} onClose={this.handleClose.bind(this)} reconnect={reconnect} debug={debug} ref={Websocket =&gt; { this.refWebSocket = Websocket; }}/&gt; ); }}export default ReactWebsocket; 2.在js文件中导入组件 1234567891011&lt;ReactWebsocket url='ws://192.168.200.202:9999' onMessage={this.onMessage} //接受信息的回调 onOpen={this.onOpen} //websocket打开 onClose={this.onClose} //websocket关闭 reconnect={true} debug={true} ref={Websocket =&gt; { this.refWebSocket = Websocket; }}/&gt;","link":"/2020/04/22/%E5%A6%82%E4%BD%95%E5%9C%A8react%E4%B8%AD%E4%BD%BF%E7%94%A8websocket/"},{"title":"react中使用fetch进行文件上传并与后台验证md5","text":"项目有需要文件上传的功能，所以想用fetch来实现。样式方面用的是antd的upload组件，但网络请求没有用它本身的，因为请求数据方面还是得根据后台实际需求来。 12345&lt;Upload {...props}&gt; &lt;Button type=&quot;primary&quot;&gt; &lt;Icon type=&quot;upload&quot; /&gt; 上传文件 &lt;/Button&gt;&lt;/Upload&gt; 在upload的beforeUpload获取file实例，然后通过fetch进行文件上传，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940const props = { onRemove: file =&gt; { this.setState(state =&gt; { const index = state.fileList.indexOf(file); const newFileList = state.fileList.slice(); newFileList.splice(index, 1); return { fileList: newFileList, }; }); }, beforeUpload: (file,fileList) =&gt; { const formData = new FormData(); formData.append('file', file); // You can use any AJAX library you like const url= 'http://192.168.200.204:9000/eip-service-oss/minio/file' fetch(url, { method: 'POST', body: formData, headers: { // &quot;Content-Type&quot;: &quot;multipart/form-data&quot;, &quot;Authorization&quot;: localStorage.getItem('token'), } }).then(response =&gt; response.json()) .then(response =&gt; { if(response.code==200){ message.success(`${response.data.originFileName} 文件上传成功`); Object.assign(file,{url:response.data.url},{fileName:response.data.fileName},{name1:response.data.originFileName}) this.setState(state =&gt; ({ fileList: [...state.fileList, file], })); }else{ message.error(`${response.data.originFileName} 文件上传失败`); } }) .catch(error =&gt; console.log(error)); return false; }, fileList, }; 验证md5是在react里面通过spark-md5生成文件的md5值，与传到服务器上的文件的md5值进行比对。 function get_filemd5sum(ofile,fileList) { var file = ofile; var tmp_md5; var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice, // file = this.files[0], chunkSize = 8097152, // Read in chunks of 2MB chunks = Math.ceil(file.size / chunkSize), currentChunk = 0, spark = new SparkMD5.ArrayBuffer(), fileReader = new FileReader(); fileReader.onload = function (e) { spark.append(e.target.result); // Append array buffer currentChunk++; var md5_progress = Math.floor((currentChunk / chunks) * 100); console.log(file.name + &quot; 正在处理，请稍等,&quot; + &quot;已完成&quot; + md5_progress + &quot;%&quot;); if (currentChunk &lt; chunks) { console.log(&quot;1&quot;,&quot;1&quot;) loadNext(); } else { tmp_md5 = spark.end(); console.log(tmp_md5) console.log(file.name + &quot;的MD5值是：&quot; + tmp_md5) const formdata = new FormData(); formdata.append(&apos;file&apos;, file); console.log(&quot;formData-------&quot;,formdata) const url = &quot;/file/upload?file_md5=&quot;+tmp_md5; //const url = &quot;http://192.168.200.204:9000/eip-service-oss/minio/file&quot;; //const url = &quot;http://192.168.200.202:9999/file/upload&quot;; fetch(url, { method: &apos;POST&apos;, body: formdata, headers: { // &quot;Content-Type&quot;: &quot;multipart/form-data&quot;, &quot;Authorization&quot;: localStorage.getItem(&apos;token&apos;), } }).then(response =&gt; response.json()) .then(data =&gt; { if(data.status==200){ message.success(`${file.name} 文件上传成功`); handleSetFileName(data.message,fileList) }else{ message.error(`${file.name} 文件上传失败`); } }) .catch(error =&gt; console.log(error)); } }; fileReader.onerror = function () { console.warn(&apos;oops, something went wrong.&apos;); }; function loadNext() { var start = currentChunk * chunkSize, end = ((start + chunkSize) &gt;= file.size) ? file.size : start + chunkSize; fileReader.readAsArrayBuffer(blobSlice.call(file, start, end)); } loadNext(); }至此，文件上传并验证md5的功能就全部实现了。","link":"/2020/04/29/react%E4%B8%AD%E4%BD%BF%E7%94%A8fetch%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B9%B6%E9%AA%8C%E8%AF%81md5/"},{"title":"Android多语言切换（适用于8.0以上）","text":"首先关于语言配置的文件就不赘述了，在setting里面新建resoure资源就可以了。下面主要讲的是如何针对于8.0版本以上的系统做适配，因为8.0对多语言的改动还是蛮大的。 一.8.0之前如何写多语言1234567891011121314151617181920212223242526272829 Resources resources = context.getApplicationContext().getResources(); DisplayMetrics dm = resources.getDisplayMetrics(); Configuration config = resources.getConfiguration(); Locale locale = getSetLanguageLocale(context);//获取sp里面保存的语言 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { config.setLocale(locale); } else { config.locale = locale; } resources.updateConfiguration(config, dm);/** * 获取选择的语言设置 * * @param context * @return */ private static Locale getSetLanguageLocale(Context context) { switch (Store.getLanguageType()) { case &quot;null&quot;://跟随系统 return getSystemLocale(); case &quot;zh&quot;://英语 return Locale.CHINESE; case &quot;en&quot;://汉语 return Locale.ENGLISH; default://默认 汉语 return Locale.CHINESE; } } 123456789101112131415161718192021222324252627/** * 本地存储语言 * * SharedPrefences操作方法 */public class Store { public static String LANGUAGE_KEY = &quot;language&quot;; public static String LANGUAGE_TYPE_CHINESE = &quot;zh&quot;; public static String LANGUAGE_TYPE_ENGLISH = &quot;en&quot;; public static String LANGUAGE_TYPE_NUll = &quot;null&quot;; public static String getLanguageType() { Context context = ContextUtil.getcontext(); SharedPreferences sp = context.getSharedPreferences(LANGUAGE_KEY, Context.MODE_WORLD_READABLE); return sp.getString(LANGUAGE_KEY, LANGUAGE_TYPE_NUll); } public static void insertLanguageType(String type) { Context context = ContextUtil.getcontext(); SharedPreferences sp = context.getSharedPreferences(LANGUAGE_KEY, Context.MODE_WORLD_READABLE); SharedPreferences.Editor editor = sp.edit(); editor.putString(LANGUAGE_KEY, type); editor.commit(); }} 二.8.0后作出的改动123456789101112131415161718192021222324public static void changeLanguage() { Context context = ContextUtil.getcontext(); //获取设置 String sta = Store.getLanguageType(); if (!Store.LANGUAGE_TYPE_NUll.equals(sta)) { Resources resources = context.getApplicationContext().getResources(); DisplayMetrics dm = resources.getDisplayMetrics(); Configuration config = resources.getConfiguration(); Locale locale = getSetLanguageLocale(context);//获取sp里面保存的语言 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { config.setLocale(locale); } else { config.locale = locale; } if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { LocaleList localeList = new LocaleList(locale); LocaleList.setDefault(localeList); config.setLocales(localeList); context.getApplicationContext().createConfigurationContext(config); Locale.setDefault(locale); } resources.updateConfiguration(config, dm); } } 当版本8.0以后，增加了通过config.setLocales去修改多语言。 当然app都会在Application类的onCreate方法执行读取该APP设置的语言进行设置更换的方法，但是我们现在还需要在Application类加这段代码。 12345@Overridepublic void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); ChangeLanguageUtil.changeLanguage();} 三.在高版本中废弃了updateConfiguration方法，替代方法为createConfigurationContext。意思就是多语言需要传递到context，所以每个context都得有，所以想了一个办法，每个activity都会有基类即是自己定义的BaseActivity，所以我们只要在基类加如下代码即可适配8.0或更高版本。 1234@Overrideprotected void attachBaseContext(Context base) { super.attachBaseContext(LanguageUtils.attachBaseContext(base));} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LanguageUtils { public static Context attachBaseContext(Context context) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { // 8.0需要使用createConfigurationContext处理 return updateResources(context); } else { return context; } } @TargetApi(Build.VERSION_CODES.N) private static Context updateResources(Context context) { Resources resources = context.getResources(); Locale locale = getSetLanguageLocale(context);//获取sp里面保存的语言 Configuration configuration = resources.getConfiguration(); configuration.setLocale(locale); configuration.setLocales(new LocaleList(locale)); return context.createConfigurationContext(configuration); } /** * 获取选择的语言设置 * * @param context * @return */ private static Locale getSetLanguageLocale(Context context) { switch (Store.getLanguageType()) { case &quot;null&quot;://跟随系统 return getSystemLocale(); case &quot;zh&quot;://汉语 return Locale.CHINESE; case &quot;en&quot;://英语 return Locale.ENGLISH; default://默认 汉语 return Locale.CHINESE; } } /** * 获取系统local * * @return */ public static Locale getSystemLocale() { Locale locale = Resources.getSystem().getConfiguration().locale; Log.e(&quot;SNN&quot;, &quot;系统获取 ：getLanguage : &quot; + Locale.getDefault().getLanguage()); return locale; }} 测试完毕，在8.0或更高版本可以正常切换多语言了。","link":"/2020/08/05/Android%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E8-0%E4%BB%A5%E4%B8%8A%EF%BC%89/"},{"title":"android选择文件后返回路径无法正常读取文件","text":"原先之前用的是通过uri然后通过系统的getPath获取路径，后来发现返回的路径获取不到文件了。 12Uri uri = data.getData();String path = getPath(this, uri); 后来查了一下，原来在4.4之后api对uri有了一个调整，所以获取路径的代码也得做调整，重新写了一个获取路径的方法，这样子就可以正常读取文件了。 12Uri uri = data.getData();String path = getPathByUri(this, uri); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//从Uri获取文件绝对路径 @SuppressLint(&quot;NewApi&quot;) public static String getPathByUri4kitkat(final Context context, final Uri uri) { final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT; if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) { if (isExternalStorageDocument(uri)) {// ExternalStorageProvider final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(&quot;:&quot;); final String type = split[0]; if (&quot;primary&quot;.equalsIgnoreCase(type)) { return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1]; } } else if (isDownloadsDocument(uri)) {// DownloadsProvider final String id = DocumentsContract.getDocumentId(uri); final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id)); return getDataColumn(context, contentUri, null, null); } else if (isMediaDocument(uri)) {// MediaProvider final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(&quot;:&quot;); final String type = split[0]; Uri contentUri = null; if (&quot;image&quot;.equals(type)) { contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; } else if (&quot;video&quot;.equals(type)) { contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; } else if (&quot;audio&quot;.equals(type)) { contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; } final String selection = &quot;_id=?&quot;; final String[] selectionArgs = new String[] { split[1] }; return getDataColumn(context, contentUri, selection, selectionArgs); } } else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) {// MediaStore // (and // general) return getDataColumn(context, uri, null, null); } else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) {// File return uri.getPath(); } return null; } public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) { Cursor cursor = null; final String column = &quot;_data&quot;; final String[] projection = { column }; try { try{ cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); }catch (Exception e) { } if (cursor != null &amp;&amp; cursor.moveToFirst()) { final int column_index = cursor.getColumnIndexOrThrow(column); return cursor.getString(column_index); } } finally { if (cursor != null) cursor.close(); } return null; } public static boolean isExternalStorageDocument(Uri uri) { return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority()); } public static boolean isDownloadsDocument(Uri uri) { return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()); } public static boolean isMediaDocument(Uri uri) { return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()); }","link":"/2020/08/10/%E8%A7%A3%E5%86%B3android4-4%E4%BB%A5%E4%B8%8A%E6%9C%BA%E5%9E%8B%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E8%BF%94%E5%9B%9E%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"react中umi升级2.0到3.0（antd项目）","text":"因为项目要用到antd4.0最新的紧凑模式，所以决定使用官网推荐的使用方式，将umi升到3.0，设置属性compact为true即可。下面是项目主要的修改及配置。 package.json123456789101112{ &quot;dependencies&quot;: {- &quot;umi&quot;: &quot;^2&quot;+ &quot;umi&quot;: &quot;^3&quot; }}{ &quot;devDependencies&quot;: {- &quot;umi-plugin-react&quot;: &quot;^1&quot;+ &quot;@umijs/preset-react&quot;: &quot;^1&quot; }} config.jsumi配置方式修改了，所以config.js文件中也要相应修改 123456789101112export default {- plugins: [- ['umi-plugin-react', {- dva: {},- antd: {},- ...- }]- ],+ dva: {},+ antd: {},+ ...} 代码层删除了 routes、library、dll、hardSource、pwa、hd、fastClick、chunks，不可继续使用内置 dynamicImport、title、scripts、headScripts、metas 和 links 到 Umi 中，可继续使用 12- import Link from 'umi/link';+ import { Link } from 'umi'; 1234- import router from 'umi/router';+ import { history } from 'umi';- router.push('/foo');+ history.push('/foo'); 123456# 别名- background: url(@/utils/utils.less);+ background: url(~@/utils/utils.less);# 三方库- @import url(foo/bar.css);+ @import url(~foo/bar.css); 还有一些注意的问题1.一共升级了3个项目，前两个项目是好的，最后一个紧凑一直出不来，之前试了一直以为是umi没有配置好，但是试了好几次都不行。最后反复调试，才发现我某一个文件中曾经导入了这个css文件。 1import 'antd/dist/antd.css'; 这就导致css文件把我的紧凑模型的less给覆盖掉了，所以使用antd的小伙伴需要注意一下。 2.window.g_app._store获取不到dispatch了。得使用getDvaApp 12345import { getDvaApp } from 'umi';getDvaApp()._store.dispatch({ type: 'login/jumpToLogin',}); 还有其他升级的需要注意的也会陆续更新。","link":"/2020/09/27/react%E4%B8%ADumi%E5%8D%87%E7%BA%A72-0%E5%88%B03-0%EF%BC%88antd%E9%A1%B9%E7%9B%AE%EF%BC%89/"},{"title":"android10关于文件读取不到的解决办法","text":"最近项目中有人提出来说拍照没法拍，我的第一反应是之前项目一直是好的，按道理不是硬件代码的问题。结合了自己昨天刚把测试机升到了android10，所以箭头指向了android版本。于是用了测试机试了一下，果不其然也报错了。错误信息是 java.io.FileNotFoundException。就是找不到该文件了，于是翻阅资料发现，在AndroidManifest.xml 里的application中添加 android:requestLegacyExternalStorage=“true” 临时解决。可以兼容到Android 11。或者targetsdk 降低到29以下。 12345&lt;application android:requestLegacyExternalStorage=&quot;true&quot;&gt;``` 还有类似还有一个问题，就是我申请了读写权限，但是就是指向不到文件，所以就一直没办法拍照。后来研究发现，是因为还需要再手动给一次权限。 if (ActivityCompat.checkSelfPermission(WaitActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(WaitActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1);}```","link":"/2020/09/30/android/"},{"title":"windows10如何重启linux服务器上的nginx服务器","text":"因为我们项目是搭建在linux系统上的，现在我们的nginx的cong.f文件需要修改，所以需要重启nginx服务。 一.下载软件SecureCrt，连接linux服务器 这里输入你服务器的密码，点击确定。出现下面界面。 即为连接成功。 二.重启nginx服务输入nginx -s reload ，测试验证重启成功","link":"/2020/09/30/windows10%E5%A6%82%E4%BD%95%E9%87%8D%E5%90%AFlinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"android","slug":"android","link":"/tags/android/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"Springboot","slug":"Springboot","link":"/tags/Springboot/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Canvas","slug":"Canvas","link":"/tags/Canvas/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Cascader","slug":"Cascader","link":"/tags/Cascader/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Fetch","slug":"Fetch","link":"/tags/Fetch/"},{"name":"md5","slug":"md5","link":"/tags/md5/"},{"name":"upload","slug":"upload","link":"/tags/upload/"},{"name":"Locale","slug":"Locale","link":"/tags/Locale/"},{"name":"多语言","slug":"多语言","link":"/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"uri","slug":"uri","link":"/tags/uri/"},{"name":"file","slug":"file","link":"/tags/file/"},{"name":"umi","slug":"umi","link":"/tags/umi/"},{"name":"antd","slug":"antd","link":"/tags/antd/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"securecrt","slug":"securecrt","link":"/tags/securecrt/"}],"categories":[{"name":"android","slug":"android","link":"/categories/android/"},{"name":"Springboot","slug":"Springboot","link":"/categories/Springboot/"},{"name":"Vue","slug":"Springboot/Vue","link":"/categories/Springboot/Vue/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"umi","slug":"React/umi","link":"/categories/React/umi/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"}]}